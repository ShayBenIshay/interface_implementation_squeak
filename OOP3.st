Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'PartC' stamp: 'SBI 12/23/2019 22:25'!isKindOf: aClassOrInterface^( (self class behavesLike includes: aClassOrInterface) or: (self class == aClassOrInterface) or: (self class inheritsFrom: aClassOrInterface)).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'initialize-release' stamp: 'LY 12/22/2019 23:20'!ambiguities	| interfaces conflicts resSortedCollection |		(self = MyObject) ifTrue:[^SortedCollection new].		resSortedCollection := SortedCollection new.	interfaces := self behavesLike.	interfaces do: [:interface | resSortedCollection addAll: interface selectors].	conflicts := resSortedCollection reject: [:method | (resSortedCollection occurrencesOf: method) = 1].	^conflicts asSet asSortedCollection.! !!MyObject class methodsFor: 'initialize-release' stamp: 'LY 12/21/2019 19:12'!behavesLike	| newSet forEachInterfaceSet superClasses |		newSet := Set new.		(self isMemberOf: MyObject) ifTrue: [^newSet].		forEachInterfaceSet := Set new.	superClasses := self getSuperClasses.		newSet addAll: behavesLike.	newSet do: [:interface | forEachInterfaceSet addAll: (interface behavesLike)].	newSet addAll: forEachInterfaceSet.		superClasses do: [:superClass | newSet addAll: (superClass behavesLike)].		(self isInterface) ifTrue: [newSet add: self].			^newSet.! !!MyObject class methodsFor: 'initialize-release' stamp: 'SBI 12/24/2019 15:02'!compile: code	|args|	args := (Parser new parse: code class: MyObject) arguments collect: [:each | each name].	"interfaces can compile only empty methods or dafult methods(with less then 2 arguments)"	(isInterface)	ifTrue: [		((code lineNumber: 1) includesSubString: 'default')		ifTrue:[			(args size >= 2) ifTrue: [AssertionFailure signal: 'Interfaces are not allowed to have non default methods that define behavior!!']			]		ifFalse: [			(code lineCount > 1) ifTrue: [AssertionFailure signal: 'Interfaces are not allowed to have non default methods that define behavior!!']				]		].	^self compile: code notifying: nil.! !!MyObject class methodsFor: 'initialize-release' stamp: 'SBI 12/23/2019 22:22'!compile: aSourceCode where: anOrderedCollection| res str temp i lines args |args := OrderedCollection new.str := String new.args := (Parser new parse: aSourceCode class: MyObject) arguments collect: [:each | each name].(anOrderedCollection size ~= args size)ifTrue: [	(AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!').	].i := 1.anOrderedCollection do: [:each|(each ~= nil) ifTrue:[ str := str , Character cr,'(',(args at: i),' isKindOf: ', each,') 	 ifFalse: [ (AssertionFailure signal: ', $','Type mismatch!! Argument ', i, ' should be ', each, $', ')].'].	 i := i+1].temp := $ .(aSourceCode lineNumber: 2) do: [:c|(temp ==$ )ifTrue: [(c ~= $ ) ifTrue: [temp:= c]]].lines := aSourceCode lines.(temp == $|)ifTrue: [i := 3. res := (lines at: 1), Character cr, (lines at: 2)]ifFalse: [i:=2. res := (lines at: 1)].res := res, str.[ i <= (lines size)] whileTrue: [res := res , Character cr, (lines at: i). i:=i+1 ].^self compile: res notifying: nil.! !!MyObject class methodsFor: 'initialize-release' stamp: 'LY 12/21/2019 22:25'!getMethods	"Get all the methods of a class, including methods from interfaces"	| methods interfaces |		(self = MyObject) ifTrue: [^Set new].	methods := Set new.	interfaces := self behavesLike.	interfaces do: [:interface | methods addAll: interface selectors].	methods addAll: self selectors.	^methods.! !!MyObject class methodsFor: 'initialize-release' stamp: 'LY 12/21/2019 19:10'!getSuperClasses	"Get the super classes up to MyObject, MyObject not included"	| returnedSet |		(self = MyObject) ifTrue: [^(Set new)].		(superclass == MyObject) 	ifTrue: [^(Set new)]	ifFalse: [		returnedSet := superclass getSuperClasses.		returnedSet add: superclass.		^returnedSet	].! !!MyObject class methodsFor: 'initialize-release' stamp: 'SBI 12/24/2019 17:27'!isImplemented	| myObjectSubclasses myObjectClasses classesBehaveLikeInterface behavesLikeSelf methods classMethods diffClasses |	isInterface ifFalse: [AssertionFailure signal: (self asString), ' is not an interface!!'].		behavesLikeSelf := self behavesLike.	methods := Set new.	behavesLikeSelf do: [:interface | methods addAll: (interface selectors)].	methods := methods reject: [:m | m asString includesSubString: 'default'].	myObjectSubclasses := MyObject allSubclasses.	myObjectClasses := myObjectSubclasses reject: [:c | c isInterface].	(myObjectClasses isEmpty) ifTrue: [^false].	classesBehaveLikeInterface := myObjectClasses select: [:c | (c behavesLike) includes: self].	(methods isEmpty and: [(classesBehaveLikeInterface isEmpty) not]) ifTrue: [^true].	classesBehaveLikeInterface do: [ :class | 		classMethods := class selectors.		diffClasses	:=	methods reject: [:method | classMethods includes: method].		(diffClasses isEmpty) ifTrue: [^true].	].	^false.! !!MyObject class methodsFor: 'initialize-release' stamp: 'LY 12/20/2019 22:28'!isInterface	^isInterface! !!MyObject class methodsFor: 'initialize-release' stamp: 'SBI 12/24/2019 20:58'!new	| methods behavesLikeIN pred|		pred:=true.	isInterface ifTrue: [AssertionFailure signal: 'Interfaces can not be instantiated!!'].		behavesLikeIN := self behavesLike.	methods := Set new.	behavesLikeIN do: [:interface | methods addAll: (interface selectors)].	methods := methods reject: [:s | s asString includesSubString: 'default'].	methods do: [:s | ((self allSelectors) includes: s) ifFalse: [			AssertionFailure signal: 'Can not instantiate an Abstract class!!'						]].	^self basicNew initialize.! !!MyObject class methodsFor: 'initialize-release' stamp: 'SBI 12/24/2019 12:32'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries:  poolDictionaries category: aCategoryName	| newCollection newSubclass |	(self isInterface)	ifTrue: [AssertionFailure signal: 'Interfaces must derive from MyObject!!'].		newCollection := Set new.	newSubclass := self subclass: aSubclassName isInterface: false behavesLike: newCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries:  poolDictionaries category: aCategoryName.	^newSubclass.	! !!MyObject class methodsFor: 'initialize-release' stamp: 'SBI 12/24/2019 21:17'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	| newSubclass methods defMethods|		(isInterface and: [self ~= MyObject])	ifTrue: [AssertionFailure signal: 'Interfaces must derive from MyObject!!'].		(isInterface and: [instVarNames notEmpty])	ifTrue: [AssertionFailure signal: 'Interfaces can not have state!!'].		((self isInterface) and: [isInterface not])	ifTrue: [AssertionFailure signal: 'Classes can not derive from an interface!!'].		aCollection do: [:interface | (interface isInterface) ifFalse: [AssertionFailure signal: 'Can not behave like a non-interface!!']].		newSubclass := super subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName.	newSubclass instVarNamed: 'isInterface' put: isInterface.	newSubclass instVarNamed: 'behavesLike' put: aCollection.	defMethods := Set new.	methods := Set new.	aCollection do: [:interface | methods addAll: (interface selectors).	methods := methods select: [:s | s asString includesSubString: 'default'].	methods do: [:s | defMethods add: (interface decompile: s)]	].	defMethods do: [:defaultmethod | newSubclass compile: (defaultmethod asString) notifying: nil].	"need to extract all default methods and compile to newsubclass"	^newSubclass.	! !